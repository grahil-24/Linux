
Signals - Used by linux to start, stop and kill processes. There are more than 30 signals which can be generated by system and applications. Some of the most common signals are - 

|Signal|Value|Description|
|---|---|---|
|`1`|`SIGHUP`|Hangs up the process|
|`2`|`SIGINT`|Interrupts the process|
|`3`|`SIGQUIT`|Stops the process|
|`9`|`SIGKILL`|Unconditionally terminates the process|
|`15`|`SIGTERM`|Terminates the process if possible|
|`18`|`SIGCONT`|Continues a stopped process|
|`19`|`SIGSTOP`|Unconditionally stops, but doesn't terminate, the process|
|`20`|`SIGTSTP`|Stops or pauses the process, but doesn't terminate|

the CTRL + C key combination generates a SIGINT signal and sends it to processes running currently in the shell. When this signal is passed to the shell, he shell passes these signals on to your shell script program for processing. However, a shell script's default behavior does not govern these signals, which may have an adverse effect on the script's operation. To avoid this situation, you can program your script to recognize signals and perform commands to prepare the script for the consequences of the signal

the CTRL + Z key combination pauses the process which is being executed. It generates a SIGTSTP signal. Stopping the process is different from terminating. Stopping a process, still keeps the process in memory, and able to continue running from where it was stopped. The shell refers to each process as a job and assigns each job a 'job number'. So when sending a SIGTSTP signal, the shell returns the job number, its status, and the command

```
$ sleep 60
^Z
[1]+ Stopped          sleep 60
```

stopped jobs can be viewed with the command - ps -l

Now that we have the PID of the stopped job, we can use the kill command to send SIGKILL(9) signal to terminate it. 

- **jobs** - list the current jobs
- **fg** - resume the job that's next in the queue
- **fg %[number]** - resume job [number]
- **bg** - Push the next job in the queue into the background
- **bg %[number]** - Push the job [number] into the background
- **kill %[number]** - Kill the job numbered [number]
- **kill -[signal] %[number]** - Send the signal [signal] to job number [number]
- **disown %[number]** - disown the process(no more terminal will be owner), so command will be alive even after closing the terminal.


<h4> Trapping Signals </h4>
Just like in high level programming languages, we handle exceptions using try-catch, in shell scripting we can handle signals by trapping them. 

format of trap command - trap $commands$ $signals$

Eg: 
	
		#!/bin/bash
		trap "echo 'trapped Ctrl-C'" SIGINT
		
		echo "this is a test script"
		
		count=1
		while [ $count -le 5 ]
		do
			echo "loop $count"
			sleep 1
			count=$[ $count + 1 ]
		done
		echo "end of script"
		exit


If a command in your script is interrupted by a signal, using `trap` with a specified command will not necessarily allow the interrupted command to continue where it left off. To keep critical operations flowing in your scripts, use `trap` with a null specification along with a list of the signals to trap, such as

```
trap "" SIGINT
```

trapping a script exit. We can also trigger some commands to run when our script exits by simply -
trap $command$ EXIT

Eg: 
		
		#!/bin/bash
		
		trap "echo Goodbye..." EXIT
		count=1
		while [ $count -le 5 ]
		do
			echo "Loop #$count"
			sleep 1
			count=$[ $count + 1 ]
		done

This also works if we prematurely exit the script. 

<h4> Modifying or removing a trap </h4>
To handle the trap differently in different parts of the script, simply reissue the trap. Traps can also be removed by just replacing the command with --.

Eg: 
	
	#!/bin/bash
	
	trap "echo 'Sorry... Ctrl-C is trapped'" SIGINT
	count=1
	while [ $count -le 3 ]
	do
		echo "loop #$count"
		count=$[ $count + 1 ]
		sleep 1
	done
	
	trap -- SIGINT
	echo "the trap is now removed"
	count=1
	while [ $count -le 3 ]
	do
	     echo "Second Loop #$count"
	     sleep 1
	     count=$[ $count + 1 ]
	done


After the signal trap is removed, the script handles the `SIGINT` signal in its default manner, terminating the script. However, if a signal is received before the trap is removed, the script processes it per the original `trap` command.


<h4> Running scripts in the background </h4>
Running a shell script in background mode is a fairly easy thing to do. To run a shell script in background mode from the command-line interface, just place an ampersand symbol (`&`) after the command: 
	./backgroundscript.sh &

it separates the command from the current shell and runs it as a separate background process on the system. The first thing that displays is the line
```
[1] 2595
```
number in the square bracket is the job number and 2596 is the PID. Be aware that while the background process is running, it still uses the terminal monitor for `STDOUT` and `STDERR` messages. It is a good idea to redirect `STDOUT` and `STDERR` for scripts you will be running in the background to avoid this messy display. background processes is tied to the terminal session terminal. If the terminal session exits, the background process also exits.

<h4> Running scripts without a hangup </h3>

Keep the script running in the background even when the terminal session ends. This can be achieved by using the nohup command. It blocks the incoming SIGHUP signals. This prevents the process from exiting when the terminal session ends.

Eg: nohup $command$

When this command is run, the process created is disassociated from the terminal. So the process also loses the STDERR and STDOUT output links. So, the nohup command saves the output in a file called nohup.out. Usually the nohup.out file is created in the current directory. If not possible, its created in the $HOME directory. 

When running another command using nohup in same directory, the existing nohup.out will be overwritten. 


<h4> Controlling the job </h4>

After we send SIGSTP signal (Ctrl + C) to a process. We can either kill it using kill command or restart that process. To restart, we need to send the SIGCONT signal. This process of killing, stopping, starting, resuming jobs is known as 'job control'. 

The `jobs` command uses a few different command-line parameters

| Parameter | Description                                                                               |
| --------- | ----------------------------------------------------------------------------------------- |
| `l`       | Lists the PID of the process along with the job number                                    |
| `-n`      | Lists only jobs that have changed their status since the last notification from the shell |
| `-p`      | Lists only the PIDs of the jobs                                                           |
| `-r`      | Lists only the running jobs                                                               |
| `-s`      | Lists only stopped jobs                                                                   |


<h4> Restarting stopped jobs </h4>
Stopped jobs can be restarted either as background jobs or foreground jobs. Foreground takes over the control of the terminal we're working on. 
To restart the job in the background mode run bg command. We dont need to pass Job number as parameter to restart a default job, else we need to. To restart a job in the foreground mode, use the fg command. 


<h3> Niceness </h3>
The _scheduling priority_ is the amount of CPU time the kernel assigns to the process relative to the other processes. By default, all user processes started from the shell have the same scheduling priority on the Linux system. The scheduling priority, also called the _nice value_, is an integer value. It ranges from –20 (the highest priority) to +19 (the lowest priority). By default, the Bash shell starts all user processes with a scheduling priority of 0.

Sometimes, you want to change the scheduling priority of a shell script — lowering its priority so that it doesn't take as much processing power away from other running programs or giving it a higher priority so that it gets more CPU time. You can do this by using the `nice` command.

<h4> Nice command </h4>
The `nice` command allows you to set the scheduling priority of a command as you start it. To make a command run with less priority, just use the `-n` command-line option for `nice` to specify a new priority level. Eg: 
```
	$ nice -n 10 ./jobcontrol.sh
```

The `nice` command prevents normal system users from increasing the priority of their commands. Notice that the job does run, even though the attempt to raise its priority with the `nice` command failed. Only the `root` user or users with super user privileges can elevate a job's priority

<h4> Renice command </h4>
Sometimes, you'd like to change the priority of a command that's already running on the system. The `renice` command helps in this situation. It allows you to specify the PID of a running process to change its priority. Eg: 
			```
		renice -n 10 -p 16642
		```

As with the `nice` command, the `renice` command has some limitations for those without super user privileges — you can only `renice` processes that you own, and only to a lower priority. However, the root user account and those users with super user privileges can use the `renice` command to change any process to any priority.


<h3> Scheduling Scripts </h3>
Several ways to schedule scripts - at command, crontab and anacron. 

<h4>1.  At command </h4>
specify one future time when the linux system will run the script. The `at` daemon, `atd` , runs in the background and checks the job queue for jobs to run. The `atd` daemon checks a special directory on the system (usually `/var/spool/at` or `/var/spool/cron/atjobs`) for jobs submitted using the `at` command. By default, the `atd` daemon checks this directory every 60 seconds. When a job is present, the `atd` daemon checks the time the job is set to be run. If the time matches the current time, the `atd` daemon runs the job.

Eg:
```
	at [-f filename] time
```
If you specify a time that has already passed, the `at` command runs the job at that time on the next day. The `at` command recognizes lots of different time formats:

- A standard hour and minute, such as `10:15`
- An a.m./p.m. indicator, such as `10:15PM`
- A specific named time, such as `now` , `noon` , `midnight` , or `teatime` (4:00 p.m.)

Several different date and time formats are available for use with the `at` utility. All of them are conveniently described in the `/usr/share/doc/at/timespec` file.
The job queue holds the jobs submitted by the `at` command for processing. There are 52 different job queues available for different priority levels. Job queues are referenced using lowercase letters, `a` through `z` , and uppercase letters A through Z, with `A` queue being a different queue than `a` queue.

The higher alphabetically the job queue letter, the lower the priority (higher `nice` value) the job will run under. By default, `at` jobs are submitted to the `at` job `a` queue. If you want to run a job at a lower priority, you can specify a different queue letter using the `-q` parameter. 
When an `at` job runs on the Linux system, there's no monitor associated with the job. Instead, the Linux system uses the email address of the user who submitted the `at` job as `STDOUT` and `STDERR` . Any output destined to `STDOUT` or `STDERR` is mailed to the user via the mail system.

it's best to redirect `STDOUT` and `STDERR` in your scripts when using the `at` command. If you don't want to use email or redirection with `at` , it is best to add the `-M` option to suppress any output generated by jobs using the `at` command. 

<h5> Listing all jobs in queue </h5>
using the atq command. The job listing from the `atq` command shows the job number, the date and time the system will run the job, and the job queue in which the job is stored.

<h5> Removing jobs </h5>
use command - atrm ${job number}
Current user can only remove job submitted by them only and not by others. 


<h4> 2. Cron table </h4>
run scheduled tasks on regular basis. at command only runs the job once in the future. The format for crontable - 
```
minutepasthour hourofday dayofmonth month dayofweek command
```
Eg: run a command everyday at 10:15  

15   10   *   *   *      command

Eg: run a command at 4:15pm every monday every week - 

15   16   *    *   1   command

The `cron` program runs the script using the user account that submitted the job. Thus, you must have the proper permissions to access the script (or command) and output files specified in the command listing.

Each system user can have their own `cron` table (including the root user) for running scheduled jobs. Linux provides the `crontab` command for handling the `cron` table. To list an existing `cron` table, use the `-l` parameter.  By default, each user's `cron` table file doesn't exist. To add entries to your `cron` table, use the `-e` parameter. When you do that, the `crontab` command starts a text editor with the existing `cron` table (or an empty file if it doesn't yet exist).

