
Signals - Used by linux to start, stop and kill processes. There are more than 30 signals which can be generated by system and applications. Some of the most common signals are - 

|Signal|Value|Description|
|---|---|---|
|`1`|`SIGHUP`|Hangs up the process|
|`2`|`SIGINT`|Interrupts the process|
|`3`|`SIGQUIT`|Stops the process|
|`9`|`SIGKILL`|Unconditionally terminates the process|
|`15`|`SIGTERM`|Terminates the process if possible|
|`18`|`SIGCONT`|Continues a stopped process|
|`19`|`SIGSTOP`|Unconditionally stops, but doesn't terminate, the process|
|`20`|`SIGTSTP`|Stops or pauses the process, but doesn't terminate|

the CTRL + C key combination generates a SIGINT signal and sends it to processes running currently in the shell. When this signal is passed to the shell, he shell passes these signals on to your shell script program for processing. However, a shell script's default behavior does not govern these signals, which may have an adverse effect on the script's operation. To avoid this situation, you can program your script to recognize signals and perform commands to prepare the script for the consequences of the signal

the CTRL + Z key combination pauses the process which is being executed. It generates a SIGTSTP signal. Stopping the process is different from terminating. Stopping a process, still keeps the process in memory, and able to continue running from where it was stopped. The shell refers to each process as a job and assigns each job a 'job number'. So when sending a SIGTSTP signal, the shell returns the job number, its status, and the command

```
$ sleep 60
^Z
[1]+ Stopped          sleep 60
```

stopped jobs can be viewed with the command - ps -l

Now that we have the PID of the stopped job, we can use the kill command to send SIGKILL(9) signal to terminate it. 

- **jobs** - list the current jobs
- **fg** - resume the job that's next in the queue
- **fg %[number]** - resume job [number]
- **bg** - Push the next job in the queue into the background
- **bg %[number]** - Push the job [number] into the background
- **kill %[number]** - Kill the job numbered [number]
- **kill -[signal] %[number]** - Send the signal [signal] to job number [number]
- **disown %[number]** - disown the process(no more terminal will be owner), so command will be alive even after closing the terminal.


<h4> Trapping Signals </h4>
Just like in high level programming languages, we handle exceptions using try-catch, in shell scripting we can handle signals by trapping them. 

format of trap command - trap $commands$ $signals$

Eg: 
	
		#!/bin/bash
		trap "echo 'trapped Ctrl-C'" SIGINT
		
		echo "this is a test script"
		
		count=1
		while [ $count -le 5 ]
		do
			echo "loop $count"
			sleep 1
			count=$[ $count + 1 ]
		done
		echo "end of script"
		exit


If a command in your script is interrupted by a signal, using `trap` with a specified command will not necessarily allow the interrupted command to continue where it left off. To keep critical operations flowing in your scripts, use `trap` with a null specification along with a list of the signals to trap, such as

```
trap "" SIGINT
```


